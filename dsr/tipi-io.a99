
; TIPI IO ports

	.ifdef emulation
TDOUT	EQU	>AFFF		; TIPI Data output
TCOUT	EQU	>AFFD		; TIPI Control Signal output
RDIN	EQU	>AFFB		; TIPI Control Signal output
RCIN	EQU	>AFF9		; TIPI Control Signal output
	.else
TDOUT	EQU	>5FFF		; TIPI Data output
TCOUT	EQU	>5FFD		; TIPI Control Signal output
RDIN	EQU	>5FFB		; TIPI Control Signal output
RCIN	EQU	>5FF9		; TIPI Control Signal output
	.endif

; TIPI Signal Constants
TSRSET	EQU	>0100		; Reset SYN value
TSWB	EQU	>0200		; Write Byte SYN value
TSRB	EQU	>0600		; Read Byte SYN value
TSACKM	EQU	>0300		; ACK Mask

CHUNKSIZE EQU	64		; size of blocks intervals for hash comparison


;;; Macro: handshake TSWB or handshake TSRB to signal and increment syn/ack in R2, also destroys R3.
	.defm transmit
	MOVB	R2,@TCOUT
	ANDI	R2,TSACKM
!	MOVB	@RCIN,R3
	ANDI	R3,TSACKM
	CB	R2,R3
	.ifndef emulation
	JNE	-!
	.else
	NOP
	.endif
	AI	R2,>0100
	ANDI	R2,TSACKM
	ORI	R2,#1
	.endm

;;; Macro: reset, super simple handshake with no rolling of bits.
	.defm reset
	LI	R2,TSRSET
	MOVB	R2,@TCOUT
!	CB	@RCIN,R2
	.ifndef emulation
	JNE	-!
	.else
	NOP
	.endif
	.endm

;;; SEND a message to the RPi - Sends a word containing the length of message, then the bytes of the message.
; Register usage:
;   R0 - contains length of message. Result is 0 if all bytes sent.
;   R1 - cpu address of bytes to send.
;   Destroys R2, R3, and potentially the first and last word of bytes to send.
sendmsg
	.reset
	LI	R2,TSWB
	MOVB	R0,@TDOUT
	.transmit TSWB
	SWPB	R0
	MOVB	R0,@TDOUT
	.transmit TSWB
	SWPB	R0
	
snext
	MOVB	*R1,@TDOUT
	.transmit TSWB
	INC	R1
	DEC	R0
	JNE	snext
	RT


;;; SEND a message to the RPi - Sends a word containing the length of message, then the bytes of the message.
; Register usage:
;   R0 - contains length of message. Result is 0 if all bytes sent.
;   R1 - vdp address of bytes to send.
;   Destroys R2, R3, and potentially the first and last word of bytes to send.
vsendmsg
	.reset
	LI	R2,TSWB
	MOVB	R0,@TDOUT
	.transmit TSWB
	SWPB	R0
	MOVB	R0,@TDOUT
	.transmit TSWB
	SWPB	R0

	.setvdpra R1
vsnext
	MOVB	@VDPRD,@TDOUT
	.transmit TSWB
	DEC	R0
	JNE	vsnext
	RT
	

;;; REQUEST a message from the RPi - expects a word containing the length of the message followed by the payload.
;   error checking and retries are performed
; Register usage:
;   R0 - receive buffer size. Result is number of bytes loaded into buffer.
;   R1 - cpu address of buffer
;   Destroys R0 - R8
recvmsg
	.reset
	LI	R2,TSRB
	.transmit TSRB
	MOVB	@RDIN,R4
	SWPB	R4
	.transmit TSRB
	MOVB	@RDIN,R4
	SWPB	R4
	CI	R4,>0000
	JEQ	rrt
	; should check that it will fit... but I'll come back to that.
	CLR	R0
rnblock
	LI	R2,TSRB
	CLR	R7		; block size counter
        CLR	R5		; hold a hash of received bytes
rnext
	.transmit TSRB
	MOVB	@RDIN,R8
	MOVB	R8,*R1
	; update hash for the new data
        XOR	R8,R5		; mutate old hash with new data  - old hash must be in high byte
	SWPB	R5		; move new hash to low byte
	ANDI	R5,>00FF	; prepare hash as index into table
	MOVB	@PHASH(R5),R5	; copy table value as new high byte
        INC     R1
	INC	R0
	INC	R7

	CI	R7,CHUNKSIZE
	JEQ	rhashpoint

	C	R0,R4
	JNE	rnext

	; now we need to check the hash from RPi
rhashpoint
	.transmit TSRB
	MOVB	@RDIN,R6
	LI	R2,TSWB
	CB	R5,R6		; compare computed and transmitted hashes
	JNE	rrewind

	LI	R5,>5A00
	MOVB	R5,@TDOUT
	.transmit TSWB
	
	C	R0,R4		; check if we are also done with entire message
	JNE	rnblock
rrt
	RT


rrewind
	LI	R5,>A500
	MOVB	R5,@TDOUT
	.transmit TSWB
	S	R7,R1		; rewind destination address
	S	R7,R0		;  and rewind total counter
	JMP	rnblock		; and start the block over.


;;; REQUEST a message from the RPi - expects a word containing the length of the message followed by the payload.
; Register usage:
;   R0 - receive buffer size. Result is number of bytes loaded into buffer.
;   R1 - vdp address of buffer
;   Destroys R2, R3, and R4
vrecvmsg
	.reset
	LI	R2,TSRB
	.transmit TSRB
	MOVB	@RDIN,R4
	SWPB	R4
	.transmit TSRB
	MOVB	@RDIN,R4
	SWPB	R4
	CI	R4,>0000
	JEQ	vrrt
	; should check that it will fit... but I'll come back to that.
	CLR	R0
	.setvdpwa R1
vrnblock
	LI	R2,TSRB
	CLR	R7
	CLR	R5
vrnext
	.transmit TSRB
	MOVB	@RDIN,R8
	MOVB	R8,@VDPWD
	XOR	R8,R5
	SWPB	R5
	ANDI	R5,>00FF
	MOVB	@PHASH(R5),R5
	INC	R1		; keep track of where the vdp should be writing
	INC	R0
	INC	R7
	
	CI	R7,CHUNKSIZE
	JEQ	vrhashpoint

	C	R0,R4
	JNE	vrnext

vrhashpoint
	.transmit TSRB
	MOVB	@RDIN,R6
	LI	R2,TSWB
	CB	R5,R6
	JNE	vrrewind

	LI	R2,TSWB
	LI	R5,>5A00
	MOVB	R5,@TDOUT
	.transmit TSWB
	
	C	R0,R4
	JNE	vrnblock
vrrt
	RT

vrrewind
	LI	R5,>A500
	MOVB	R5,@TDOUT
	.transmit TSWB
	S	R7,R1		; rewind destination address
	S	R7,R0		;  and rewind total counter
	.setvdpwa R1		; and update vdp with new destination address
	JMP	vrnblock




